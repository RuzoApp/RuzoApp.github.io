//GLOBAL VARIABLES
FIREBASE_ROOT = "https://studybuddyapp.firebaseio.com";

//=====================================================================
//                              USERS
//=====================================================================


// ADD NEW USER TO THE DB
function pushNewUser(first_name, last_name, email, study_session_minutes, short_break_minutes, long_break_minutes) {
    // CREATE A REFERENCE TO FIREBASE
    var usersRef = new Firebase(FIREBASE_ROOT + '/Users/active');

    //SAVE DATA TO FIREBASE
    // I generated a reference to a new location (e.i. assigned the push into a
    // variable (newUserRef)), although it is not necessary, so that we could in the future
    // get the unique ID generated by push() by doing newUserRef.key();
    var newUserRef =  usersRef.push({
        first_name: first_name,
        last_name: last_name,
        email: email,
        study_session_minutes: study_session_minutes,
        short_break_minutes: short_break_minutes,
        long_break_minutes: long_break_minutes
    });
};

// RETRIEVE AND RUNS CALLBACK FUNCTION ON ALL USERS' INFORMATION UPON REQUEST
function fetchActiveUsers(callback) {
    var usersRef = new Firebase(FIREBASE_ROOT + '/Users/active');
    var users = [];
    // WE CAN ALWAYS ADD .limitToLast(10) TO usersRef IF WE'D WANT TO FETCH JUST THE FIRST 10 USERS.
    usersRef.once("value", function(snapshot) {
        $.each(snapshot.val(), function(key, value){
            users.push(value)
        });
        callback(users);
    });
}

// MOVE USER TO DELETED
function deleteUser(userId) {
    var oldRef = new Firebase(FIREBASE_ROOT + '/Users/active/' + userId);
    var newRef = new Firebase(FIREBASE_ROOT + '/Users/deleted/' + userId);
    oldRef.once('value', function(snapshot)  {
        newRef.set(snapshot.val());
        oldRef.remove();
    });
}


//=====================================================================
//                              SUBJECTS
//=====================================================================


// Right now we are allways working with the same user, so I'm hard coding Alice's user id.
// After we'll sort user authentication, we will create the needed functionality to
// GET THE CURRENT USER
function getActiveUser() {
    // TODO: implement authentication
    return "-JsqE8CQ9Dg7LE0OKQ2P"
}

// ADD NEW SUBJECT TO THE DB
function pushNewSubject(userId, name, colour, is_deleted) {
    // CREATE A REFERENCE TO FIREBASE
    // In case this is the first subject to be pushed, this will create a new Subjects/active node.
    var subjectsRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId);

    //SAVE DATA TO FIREBASE
    // I generated a reference to a new location (e.i. assigned the push into a
    // variable (newSubjectRef)), although it is not necessary, so that we could in the future
    // get the unique ID generated by push() by doing newSubjectRef.key();
    var newSubjectRef =  subjectsRef.push({
        name: name,
        colour: colour,
        is_deleted: is_deleted
    });
};

// RETRIEVE AND RUNS CALLBACK FUNCTION ON ALL SUBJECTS' INFORMATION UPON REQUEST
function fetchActiveSubjects(userId, callback) {
    var subjectsRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId);
    subjectsRef.once("value", function(snapshot) {
        callback(snapshot.val());
    });
}

// UPDATE SUBJECT'S NAME
function changeSubjectName(userId, subjectId, newName){
    var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId + "/" + subjectId);
    subjectRef.update({
        "name": newName
    });
};


// UPDATE SUBJECT'S COLOUR
function changeSubjectColour(userId, subjectId, newColour){
    var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId + "/" + subjectId);
    subjectRef.update({
        "colour": newColour
    });
}


// MOVE SUBJECT TO DELETED
function deleteSubject(userId, subjectId) {
    var oldRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId + "/" + subjectId);
    var newRef = new Firebase(FIREBASE_ROOT + '/Subjects/deleted/' + userId + "/" + subjectId);
    oldRef.once('value', function(snapshot)  {
        newRef.set(snapshot.val());
        oldRef.remove();
    });
}


//=====================================================================
//                              TASKS
//=====================================================================


// ADD NEW TASK TO THE DB
function pushNewTask(subjectId, weekDate, title, description, assigned_date, time_estimation, creation_date, status_change_date) {
    // CREATE A REFERENCE TO FIREBASE
    // In case this is the first task to be pushed, this will create a new Tasks/active node.
    var tasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + weekDate);

    //SAVE DATA TO FIREBASE
    // I generated a reference to a new location (i.e. assigned the push into a
    // variable (newTaskRef)), although it is not necessary, so that we could in the future
    // get the unique ID generated by push() by doing newTaskRef.key();
    var newTaskRef =  tasksRef.push({
        title: title,
        description: description,
        assigned_date: assigned_date,
        time_estimation: time_estimation,
        creation_date: creation_date,
        status_change_date: status_change_date
    });
};


/// RETRIEVE AND RUNS CALLBACK FUNCTION ON ALL TASKS
function fetchActiveTasks(perSubjectCallback, preparationCallback) {
    //console.log("fetchActiveTasks(" + perSubjectCallback.name + ", " + (preparationCallback ? preparationCallback.name : undefined) + ")");
    var activeTasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active');
    activeTasksRef.once("value", function(subjects) {
        // check if we also receive the preparationCallback func.
        if (typeof preparationCallback !== 'undefined') {
            preparationCallback();
        }
        if (subjects.val() !== null) {
            subjects.forEach(function(subject) {
                var subjectId = subject.key();
                var subjectTasksDict = {};
                subject.forEach(function(week) {
                    var weekTaskData = week.val();
                    $.extend(subjectTasksDict, weekTaskData);
                });
                var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + getActiveUser() + '/' + subjectId);
                subjectRef.once("value", function(subjectSnapshot) {
                    perSubjectCallback(subjectId, subjectSnapshot.val(), subjectTasksDict);
                });
            });
        }
    });
}


function fetchActiveTasksByWeek(startOfWeek, perSubjectCallback) {
    var activeTasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active');
    activeTasksRef.once("value", function(subjects) {
        if (subjects.val() !== null) {
            subjects.forEach(function(subject) {
                if (subject.hasChild(startOfWeek)) {
                    var subjectId = subject.key();
                    var weekTasksDict = subject.val()[startOfWeek];
                    var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + getActiveUser() + '/' + subjectId);
                    subjectRef.once("value", function(subjectSnapshot) {
                        perSubjectCallback(subjectId, subjectSnapshot.val(), weekTasksDict);
                    });
                }
            });
        }
    });
}


// RETRIEVE AND RUNS CALLBACK FUNCTION ON ALL UNASSIGNED TASKS BELONGING TO A SPECIFIC SUBJECT
function fetchUnassignedActiveTasksBySubject(subjectId, callback) {
    var tasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/no_assigned_date');
    tasksRef.once("value", function(unassignedSnapshot) {
        var tasksDict = unassignedSnapshot.val();
        var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + getActiveUser() + '/' + subjectId);
        subjectRef.once("value", function(subjectSnapshot) {
            callback(subjectId, subjectSnapshot.val(), tasksDict);
        });
    });
}



function fetchAllUnassignedActiveTasks(perSubjectCallback) {
    var activeTasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active');
    activeTasksRef.once("value", function(subjects) {
        if (subjects.val() !== null) {
            subjects.forEach(function(subject) {
                var subjectId = subject.key();

                //TODO: take the next UI line from this data-handling function
                $('#tasksDivs').append('<div class="col dayColumn"><ul class="sortable-task-list" id="unassignedTasksFor' + subjectId + '"></ul></div>');

                if (subject.hasChild('no_assigned_date')) {
                    var unassignedTasksDict = subject.val()['no_assigned_date'];
                    var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + getActiveUser() + '/' + subjectId);
                    subjectRef.once("value", function(subjectSnapshot) {
                        perSubjectCallback(subjectId, subjectSnapshot.val(), unassignedTasksDict);
                    });
                }
            });
        }
    });
}



// RETRIEVE AND RUNS CALLBACK FUNCTION ON A SINGLE TASK
function fetchSingleTask(subjectId, weekDate, taskId, callback) {
    var taskRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + weekDate + '/' + taskId);
    taskRef.once("value", function(snapshot) {
        callback(subjectId, weekDate, taskId, snapshot.val());
    });
}


// UPDATE TASK'S ASSIGNED DATE
function updateAssignedDate(subjectId, oldWeekDate, newWeekDate, taskId, newAssignedDate) {
    var oldTasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + oldWeekDate + '/' + taskId);

    if (newWeekDate === oldWeekDate) {
        oldTasksRef.update({
            "assigned_date": newAssignedDate
        });
    } else {
        var newTasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + newWeekDate + '/' + taskId);

        oldTasksRef.once('value', function(snapshot)  {
            var taskData = snapshot.val();
            taskData.assigned_date = newAssignedDate;
            newTasksRef.set(taskData);
            oldTasksRef.remove();
        });
    }
}

// MOVE TASK TO DELETED
function deleteTask(subjectId, weekDate, taskId) {
    var oldRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + weekDate + '/' + taskId);
    var newRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/deleted/' + subjectId + '/' + weekDate + '/' + taskId);
    oldRef.once('value', function(snapshot)  {
        newRef.set(snapshot.val());
        oldRef.remove();
    });
}

//=====================================================================
//                              CHECKLIST ITEMS
//=====================================================================


// ADD NEW CHECKLIST ITEM TO THE DB
function pushNewChecklistItem(userId, subjectId, taskId, description, is_complete) {
    // CREATE A REFERENCE TO FIREBASE
    // In case this is the first task to be pushed, this will create a new Tasks node.
    var checklistItemRef = new Firebase(FIREBASE_ROOT + '/Users/' + userId + '/Subjects/' + subjectId + '/Tasks/' + taskId + '/Checklist_Items');

    //SAVE DATA TO FIREBASE
    // I generated a reference to a new location (e.i. assigned the push into a
    // variable (newChecklistItemRef)), although it is not necessary, so that we could in the future
    // get the unique ID generated by push() by doing newChecklistItemRef.key();
    var newChecklistItemRef =  checklistItemRef.push({
        description: description,
        is_complete: is_complete
    });
};


//=====================================================================
//                              TIME
//=====================================================================

// add one to task's count of breaks
function incrementNumOfBreaksForTask(subjectId, weekDate, taskId) {
    var tasksBreakRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + weekDate + '/' + taskId + '/number_of_breaks');
    tasksBreakRef.once("value", function(snapshot) {
        var newNum = snapshot.val() + 1;
        tasksBreakRef.set(newNum);
    });
}

// add one to a date's count of breaks
function incrementNumOfBreaksForDate(date) {
    var tasksBreakRef = new Firebase(FIREBASE_ROOT + '/heatmap_dates/' + date + '/' + getActiveUser() + '/number_of_breaks');
    tasksBreakRef.once("value", function(snapshot) {
        var newNum = snapshot.val() + 1;
        tasksBreakRef.set(newNum);
    });
}

// fetch a task's total time studied
function fetchOldTimeStudiedForTask(subjectId, weekDate, taskId, additionalTimeStudied, callback) {
    var tasksTimeStudiedRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + weekDate + '/' + taskId + '/total_seconds_studied');
    tasksTimeStudiedRef.once("value", function(snapshot) {
        callback(snapshot.val(), additionalTimeStudied, tasksTimeStudiedRef);
    });
}

// fetch a date's total time studied
function fetchOldTimeStudiedForDate(date, additionalTimeStudied, callback) {
    var tasksTimeStudiedRef = new Firebase(FIREBASE_ROOT + '/heatmap_dates/' + date + '/' + getActiveUser() + '/time_studied');
    tasksTimeStudiedRef.once("value", function(snapshot) {
        callback(snapshot.val(), additionalTimeStudied, tasksTimeStudiedRef);
    });
}
