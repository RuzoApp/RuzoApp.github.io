//GLOBAL VARIABLES
FIREBASE_ROOT = "https://studybuddyapp.firebaseio.com";

//=====================================================================
//                              USERS
//=====================================================================


// ADD NEW USER TO THE DB
function pushNewUser(first_name, last_name, email, study_session_minutes, short_break_minutes, long_break_minutes) {
    // CREATE A REFERENCE TO FIREBASE
    var usersRef = new Firebase(FIREBASE_ROOT + '/Users/active');

    //SAVE DATA TO FIREBASE
    // I generated a reference to a new location (e.i. assigned the push into a
    // variable (newUserRef)), although it is not necessary, so that we could in the future
    // get the unique ID generated by push() by doing newUserRef.key();
    var newUserRef =  usersRef.push({
        first_name: first_name,
        last_name: last_name,
        email: email,
        study_session_minutes: study_session_minutes,
        short_break_minutes: short_break_minutes,
        long_break_minutes: long_break_minutes
    });
};

// RETRIEVE AND RUNS CALLBACK FUNCTION ON ALL USERS' INFORMATION UPON REQUEST
function fetchActiveUsers(callback) {
    var usersRef = new Firebase(FIREBASE_ROOT + '/Users/active');
    var users = [];
    // WE CAN ALWAYS ADD .limitToLast(10) TO usersRef IF WE'D WANT TO FETCH JUST THE FIRST 10 USERS.
    usersRef.once("value", function(snapshot) {
        $.each(snapshot.val(), function(key, value){
            users.push(value)
        });
        callback(users);
    });
}

// MOVE USER TO DELETED
function deleteUser(userId) {
    var oldRef = new Firebase(FIREBASE_ROOT + '/Users/active/' + userId);
    var newRef = new Firebase(FIREBASE_ROOT + '/Users/deleted/' + userId);
    oldRef.once('value', function(snapshot)  {
        newRef.set(snapshot.val());
        oldRef.remove();
    });
}


//=====================================================================
//                              SUBJECTS
//=====================================================================


// Right now we are allways working with the same user, so I'm hard coding Alice's user id.
// After we'll sort user authentication, we will create the needed functionality to
// GET THE CURRENT USER
function getActiveUser() {
    // TODO: implement authentication
    return "-JsqE8CQ9Dg7LE0OKQ2P"
}

// ADD NEW SUBJECT TO THE DB
function pushNewSubject(userId, name, colour, is_deleted) {
    // CREATE A REFERENCE TO FIREBASE
    // In case this is the first subject to be pushed, this will create a new Subjects/active node.
    var subjectsRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId);

    //SAVE DATA TO FIREBASE
    // I generated a reference to a new location (e.i. assigned the push into a
    // variable (newSubjectRef)), although it is not necessary, so that we could in the future
    // get the unique ID generated by push() by doing newSubjectRef.key();
    var newSubjectRef =  subjectsRef.push({
        name: name,
        colour: colour,
        is_deleted: is_deleted
    });
};

// RETRIEVE AND RUNS CALLBACK FUNCTION ON ALL SUBJECTS' INFORMATION UPON REQUEST
function fetchActiveSubjects(userId, callback) {
    var subjectsRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId);
    subjectsRef.once("value", function(snapshot) {
        callback(snapshot.val());
    });
}

// UPDATE SUBJECT'S NAME
function changeSubjectName(userId, subjectId, newName){
    var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId + "/" + subjectId);
    subjectRef.update({
        "name": newName
    });
};


// UPDATE SUBJECT'S COLOUR
function changeSubjectColour(userId, subjectId, newColour){
    var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId + "/" + subjectId);
    subjectRef.update({
        "colour": newColour
    });
}


// MOVE SUBJECT TO DELETED
function deleteSubject(userId, subjectId) {
    var oldRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + userId + "/" + subjectId);
    var newRef = new Firebase(FIREBASE_ROOT + '/Subjects/deleted/' + userId + "/" + subjectId);
    oldRef.once('value', function(snapshot)  {
        newRef.set(snapshot.val());
        oldRef.remove();
    });
}


//=====================================================================
//                              TASKS
//=====================================================================


// ADD NEW TASK TO THE DB
function pushNewTask(subjectId, title, description, assigned_date, time_estimation, creation_date, status_change_date) {
    // CREATE A REFERENCE TO FIREBASE
    // In case this is the first task to be pushed, this will create a new Tasks/active node.
    var tasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId);

    //SAVE DATA TO FIREBASE
    // I generated a reference to a new location (i.e. assigned the push into a
    // variable (newTaskRef)), although it is not necessary, so that we could in the future
    // get the unique ID generated by push() by doing newTaskRef.key();
    var newTaskRef =  tasksRef.push({
        title: title,
        description: description,
        assigned_date: assigned_date,
        time_estimation: time_estimation,
        creation_date: creation_date,
        status_change_date: status_change_date
    });
};


// RETRIEVE AND RUNS CALLBACK FUNCTION ON ALL TASKS
function fetchActiveTasks(perSubjectCallback, preparationCallback) {
    var tasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active');
    tasksRef.once("value", function(snapshot) {
        // check if we also receive the preparationCallback func.
        if (typeof preparationCallback !== 'undefined') {
            preparationCallback();
        }
        if (snapshot.val() !== null) {
            $.each(snapshot.val(), function (subjectId, tasksDict) {
                var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + getActiveUser() + '/' + subjectId);
                subjectRef.once("value", function(subjectSnapshot) {
                    perSubjectCallback(subjectId, subjectSnapshot.val(), tasksDict);
                });
            });
        }
    });
}


// RETRIEVE AND RUNS CALLBACK FUNCTION ON ALL TASKS BELONGING TO A SPECIFIC SUBJECT
function fetchActiveTasksBySubject(subjectId, callback) {
    var tasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId);
    tasksRef.once("value", function(tasksSnapshot) {
        var subjectRef = new Firebase(FIREBASE_ROOT + '/Subjects/active/' + getActiveUser() + '/' + subjectId);
        subjectRef.once("value", function(subjectSnapshot) {
            callback(subjectId, subjectSnapshot.val(), tasksSnapshot.val());
        });
    });
}


// RETRIEVE AND RUNS CALLBACK FUNCTION  CERTAIN TASKS
function fetchCertainTasks(subjectId, taskId, callback) {
    var taskRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + taskId);
    taskRef.once("value", function(snapshot) {
        callback(subjectId, taskId, snapshot.val());
    });
}


// UPDATE TASK'S ASSIGNED DATE
function updateAssignedDate(subjectId, taskId, newAssignedDate) {
    var tasksRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + taskId);
    tasksRef.update({
        "assigned_date": newAssignedDate
    });
}


//=====================================================================
//                              CHECKLIST ITEMS
//=====================================================================


// ADD NEW CHECKLIST ITEM TO THE DB
function pushNewChecklistItem(userId, subjectId, taskId, description, is_complete) {
    // CREATE A REFERENCE TO FIREBASE
    // In case this is the first task to be pushed, this will create a new Tasks node.
    var checklistItemRef = new Firebase(FIREBASE_ROOT + '/Users/' + userId + '/Subjects/' + subjectId + '/Tasks/' + taskId + '/Checklist_Items');

    //SAVE DATA TO FIREBASE
    // I generated a reference to a new location (e.i. assigned the push into a
    // variable (newChecklistItemRef)), although it is not necessary, so that we could in the future
    // get the unique ID generated by push() by doing newChecklistItemRef.key();
    var newChecklistItemRef =  checklistItemRef.push({
        description: description,
        is_complete: is_complete
    });
};


//=====================================================================
//                              TIME
//=====================================================================

// add one to task's count of breaks
function incrementNumOfBreaksForTask(subjectId, taskId) {
    var tasksBreakRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + taskId + '/number_of_breaks');
    tasksBreakRef.once("value", function(snapshot) {
        var newNum = snapshot.val() + 1;
        tasksBreakRef.set(newNum);
    });
}

// add one to a date's count of breaks
function incrementNumOfBreaksForDate(date) {
    var tasksBreakRef = new Firebase(FIREBASE_ROOT + '/heatmap_dates/' + date + '/' + getActiveUser() + '/number_of_breaks');
    tasksBreakRef.once("value", function(snapshot) {
        var newNum = snapshot.val() + 1;
        tasksBreakRef.set(newNum);
    });
}

// fetch a task's total time studied
function fetchOldTimeStudiedForTask(subjectId, taskId, additionalTimeStudied, callback) {
    var tasksTimeStudiedRef = new Firebase(FIREBASE_ROOT + '/Tasks/' + getActiveUser() + '/active/' + subjectId + '/' + taskId + '/total_seconds_studied');
    tasksTimeStudiedRef.once("value", function(snapshot) {
        callback(snapshot.val(), additionalTimeStudied, tasksTimeStudiedRef);
    });
}

// fetch a date's total time studied
function fetchOldTimeStudiedForDate(date, additionalTimeStudied, callback) {
    var tasksTimeStudiedRef = new Firebase(FIREBASE_ROOT + '/heatmap_dates/' + date + '/' + getActiveUser() + '/time_studied');
    tasksTimeStudiedRef.once("value", function(snapshot) {
        callback(snapshot.val(), additionalTimeStudied, tasksTimeStudiedRef);
    });
}
